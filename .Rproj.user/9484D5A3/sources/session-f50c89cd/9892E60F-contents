// [[Rcpp::depends(RcppParallel)]]
#include <Rcpp.h>
#include <RcppParallel.h>
#include <algorithm>
#include <cmath>
#include <random>
#include <vector>
#include <numeric>

using namespace Rcpp;
using namespace RcppParallel;
using namespace std;

// Function to calculate Pearson correlation
inline double pearsonCorrelation(const vector<double> &xData, const vector<double> &yData) {
  int n = xData.size();
  double mean_x = std::accumulate(xData.begin(), xData.end(), 0.0) / n;
  double mean_y = std::accumulate(yData.begin(), yData.end(), 0.0) / n;
  double num = 0.0, den_x = 0.0, den_y = 0.0;
  for (int i = 0; i < n; i++) {
    double dx = xData[i] - mean_x;
    double dy = yData[i] - mean_y;
    num += dx * dy;
    den_x += dx * dx;
    den_y += dy * dy;
  }
  if (den_x <= 0.0 || den_y <= 0.0) return NA_REAL;
  return num / sqrt(den_x * den_y);
}

// Function to calculate Spearman correlation
inline double spearmanCorrelation(const vector<int> &xRank, const vector<int> &yRank) {
  int n = xRank.size();
  double mean_x = (n - 1) / 2.0;
  double mean_y = (n - 1) / 2.0;
  double num = 0.0, den_x = 0.0, den_y = 0.0;
  for (int i = 0; i < n; i++) {
    double dx = xRank[i] - mean_x;
    double dy = yRank[i] - mean_y;
    num += dx * dy;
    den_x += dx * dx;
    den_y += dy * dy;
  }
  if (den_x <= 0.0 || den_y <= 0.0) return NA_REAL;
  return num / sqrt(den_x * den_y);
}

// Function to calculate Kendall correlation
inline double kendallCorrelation(const vector<double> &xData, const vector<double> &yData) {
  int n = xData.size();
  int concordant = 0, discordant = 0;
  for (int i = 0; i < n - 1; i++) {
    for (int j = i + 1; j < n; j++) {
      double dx = xData[i] - xData[j];
      double dy = yData[i] - yData[j];
      double prod = dx * dy;
      if (prod > 0) concordant++;
      else if (prod < 0) discordant++;
    }
  }
  double denom = 0.5 * n * (n - 1);
  if (denom == 0) return NA_REAL;
  return (concordant - discordant) / denom;
}

// Function to calculate the Gini correlation coefficient
double calcGCCNormalized(const vector<double> &xData, const vector<int> &xIdx, const vector<int> &yIdx, const vector<double> &wt, int n) {
  vector<std::pair<double, int>> x_sorted(n), y_sorted(n);
  for (size_t i = 0; i < n; ++i) {
    x_sorted[i] = {xData[i], xIdx[i]};
    y_sorted[i] = {xData[i], yIdx[i]};
  }

  std::sort(x_sorted.begin(), x_sorted.end());
  std::sort(y_sorted.begin(), y_sorted.end());

  vector<double> rank_x(n), rank_y(n);
  for (size_t i = 0; i < n; ++i) {
    rank_x[x_sorted[i].second] = i + 1;
    rank_y[y_sorted[i].second] = i + 1;
  }

  double sum_x = std::accumulate(xData.begin(), xData.end(), 0.0);
  double sum_rank_x = std::accumulate(rank_x.begin(), rank_x.end(), 0.0);
  double sum_rank_y = std::accumulate(rank_y.begin(), rank_y.end(), 0.0);

  double sum_x_rank_y = 0.0;
  double sum_x_rank_x = 0.0;
  for (size_t i = 0; i < n; ++i) {
    sum_x_rank_y += xData[i] * rank_y[i];
    sum_x_rank_x += xData[i] * rank_x[i];
  }

  double cov_x_rank_y = sum_x_rank_y - (sum_x * sum_rank_y / n);
  double cov_x_rank_x = sum_x_rank_x - (sum_x * sum_rank_x / n);

  if (cov_x_rank_x == 0.0) {
    return 0.0; // Avoid division by zero
  }

  double giniRaw = cov_x_rank_y / cov_x_rank_x;

  // Normalize Gini correlation to be between -1 and 1
  // double minGini = -1.0;
  // double maxGini = 1.0;
  // return std::max(minGini, std::min(maxGini, giniRaw));
  return giniRaw;
}

// Function to perform bootstrapping for Gini correlation p-value
double bootstrapGiniPValue(double originalGCC, vector<double> &xData, vector<int> &xIdx, vector<double> &yData, vector<int> &yIdx, vector<double> &wt, int bootstraps) {
  int n = xData.size();
  std::random_device rd;
  std::mt19937 rng(rd());
  std::uniform_int_distribution<int> dist(0, n - 1);

  int extremeCount = 0;
  for (int b = 0; b < bootstraps; b++) {
    // Resample with replacement
    vector<int> sampleIdx(n);
    for (int i = 0; i < n; i++) {
      sampleIdx[i] = dist(rng);
    }

    // Calculate bootstrapped Gini correlation
    double numerator = 0, denominator = 0;
    for (int i = 0; i < n; i++) {
      numerator += wt[i] * xData[sampleIdx[yIdx[i]]];
      denominator += wt[i] * xData[sampleIdx[xIdx[i]]];
    }
    double bootstrapGCC = denominator > 0 ? numerator / denominator : 0;

    // Check if bootstrapped Gini is more extreme
    if (std::fabs(bootstrapGCC) >= std::fabs(originalGCC)) {
      extremeCount++;
    }
  }
  return static_cast<double>(extremeCount) / bootstraps;
}

// Function to perform permutation tests

double permutationTests(double originalGCC, vector<double> &xData, vector<int> &xIdx, vector<double> &yData, vector<int> &yIdx, vector<double> &wt, int perm) {
  int n = xData.size();
  vector<int> yVec(yIdx);
  vector<int> xVec(xIdx);
  // Precompute denominators
  double xDenominator = 0;
  double yDenominator = 0;

  for (int i = 0; i < n; i++) {
    xDenominator += wt[i] * xData[xIdx[i]];
    yDenominator += wt[i] * yData[yIdx[i]];
  }
  if (xDenominator == 0 || yDenominator == 0) {
    return 1.0;
  }
  int m = 0; // Counter for extreme values
  std::vector<int> indices(xVec.size());
  std::iota(indices.begin(), indices.end(), 0);
  std::mt19937 rng(std::random_device{}());
  for (int p = 0; p < perm; p++) {
    std::shuffle(indices.begin(), indices.end(), rng);
    for (size_t i = 0; i < indices.size(); ++i) {
      xVec[i] = xVec[indices[i]];
      yVec[i] = yVec[indices[i]];
    }
    double xNumerator = 0;
    double yNumerator = 0;
    for (int i = 0; i < n; i++) {
      xNumerator += wt[i] * xData[yVec[i]];
      yNumerator += wt[i] * yData[xVec[i]];
    }
    double xGCC = xNumerator / xDenominator;
    double yGCC = yNumerator / yDenominator;
    if (originalGCC > 0 ? (xGCC > originalGCC || yGCC > originalGCC) : (xGCC < originalGCC || yGCC < originalGCC)) {
      m++;
    }
    if ((p == 10 && m / p > 0.5) || (p == 100 && m / p > 0.2) || (p == 500 && m / p > 0.1)) {
      perm = p;
    }
  }
  return static_cast<double>(m) / perm;
}



// ===== Parallel Worker =====
struct MultiCorrWorker : public Worker {
  const RMatrix<double> data;
  const RMatrix<int> ranks;
  const RVector<double> wt;
  const RVector<int> src;
  const RVector<int> tgt;
  int nSamples;
  int bootstrapIterations;
  bool useBestGCC;
  bool asymmetricGCC;

  RVector<double> gcc, gcc_pval, gcc1_vec, gcc2_vec;
  RVector<double> pcc, pcc_pval, scc, scc_pval, kcc, kcc_pval;

  MultiCorrWorker(const NumericMatrix data,
                  const IntegerMatrix ranks,
                  const NumericVector wt,
                  const IntegerVector src,
                  const IntegerVector tgt,
                  int nSamples,
                  int bootstrapIterations,
                  bool useBestGCC,
                  bool asymmetricGCC,
                  NumericVector gcc, NumericVector gcc_pval,
                  NumericVector gcc1_vec, NumericVector gcc2_vec,
                  NumericVector pcc, NumericVector pcc_pval,
                  NumericVector scc, NumericVector scc_pval,
                  NumericVector kcc, NumericVector kcc_pval)
    : data(data), ranks(ranks), wt(wt),
      src(src), tgt(tgt),
      nSamples(nSamples),
      bootstrapIterations(bootstrapIterations),
      useBestGCC(useBestGCC),
      asymmetricGCC(asymmetricGCC),
      gcc(gcc), gcc_pval(gcc_pval),
      gcc1_vec(gcc1_vec), gcc2_vec(gcc2_vec),
      pcc(pcc), pcc_pval(pcc_pval),
      scc(scc), scc_pval(scc_pval),
      kcc(kcc), kcc_pval(kcc_pval) {}

  void operator()(size_t begin, size_t end) {
    std::vector<double> xData(nSamples), yData(nSamples), wtVec(nSamples);
    std::vector<int> xRank(nSamples), yRank(nSamples);
    wtVec.assign(wt.begin(), wt.end());

    for (size_t i = begin; i < end; i++) {
      int i1 = src[i];
      int i2 = tgt[i];

      if (i1 < 0 || i1 >= data.nrow() || i2 < 0 || i2 >= data.nrow()) {
        gcc[i] = NA_REAL; gcc_pval[i] = NA_REAL;
        gcc1_vec[i] = NA_REAL; gcc2_vec[i] = NA_REAL;
        pcc[i] = NA_REAL; pcc_pval[i] = NA_REAL;
        scc[i] = NA_REAL; scc_pval[i] = NA_REAL;
        kcc[i] = NA_REAL; kcc_pval[i] = NA_REAL;
        continue;
      }

      for (int j = 0; j < nSamples; j++) {
        xData[j] = data(i1, j);
        yData[j] = data(i2, j);
        xRank[j] = ranks(i1, j);
        yRank[j] = ranks(i2, j);
      }

      // Prepare vectors for calcGCC
      vector<double> sd = xData;
      vector<double> td = yData;
      vector<int> sr = xRank;
      vector<int> tr = yRank;
      vector<double> w = wtVec;

      // === Normalized GCC calculation ===
      double gcc1_val = calcGCCNormalized(sd, sr, tr, w, nSamples);
      double gcc2_val = calcGCCNormalized(td, tr, sr, w, nSamples);
      gcc1_vec[i] = gcc1_val;
      gcc2_vec[i] = gcc2_val;

      double chosen_gcc;
      if (asymmetricGCC) {
        chosen_gcc = gcc1_val;
      } else {
        chosen_gcc = useBestGCC
        ? ((std::fabs(gcc1_val) >= std::fabs(gcc2_val)) ? gcc1_val : gcc2_val)
          : (gcc1_val + gcc2_val) / 2.0;
      }
      gcc[i] = chosen_gcc;

      // === Bootstrapped p-value ===
      if (bootstrapIterations > 0) {
        gcc_pval[i] = permutationTests(chosen_gcc, sd, sr, td, tr, w, bootstrapIterations);
      } else {
        gcc_pval[i] = NA_REAL;
      }

      // === PCC ===
      double r_pcc = pearsonCorrelation(xData, yData);
      pcc[i] = r_pcc;
      if (R_finite(r_pcc)) {
        double t_stat = r_pcc * std::sqrt((nSamples - 2) / (1 - r_pcc * r_pcc));
        pcc_pval[i] = 2 * R::pt(-std::fabs(t_stat), nSamples - 2, 1, 0);
      } else {
        pcc_pval[i] = NA_REAL;
      }

      // === SCC ===
      double r_scc = spearmanCorrelation(xRank, yRank);
      scc[i] = r_scc;
      if (R_finite(r_scc)) {
        double t_stat = r_scc * std::sqrt((nSamples - 2) / (1 - r_scc * r_scc));
        scc_pval[i] = 2 * R::pt(-std::fabs(t_stat), nSamples - 2, 1, 0);
      } else {
        scc_pval[i] = NA_REAL;
      }

      // === KCC ===
      double r_kcc = kendallCorrelation(xData, yData);
      kcc[i] = r_kcc;
      if (R_finite(r_kcc)) {
        double z_stat = r_kcc * std::sqrt((9 * nSamples * (nSamples - 1)) /
                                          (2 * (2 * nSamples + 5)));
        kcc_pval[i] = 2 * R::pnorm(-std::fabs(z_stat), 0, 1, 1, 0);
      } else {
        kcc_pval[i] = NA_REAL;
      }
    }
  }
};

// [[Rcpp::export]]
DataFrame multi_corr_necorr(NumericMatrix expression,
                            IntegerMatrix ranks,
                            IntegerVector src,
                            IntegerVector tgt,
                            int bootstrapIterations = 0,
                            bool useBestGCC = false,
                            bool asymmetricGCC = false) {
  int nEdges = src.size();
  int nSamples = expression.ncol();

  // Initialize weights (example: rank-based weights) and center them around zero
  // NumericVector wt(nSamples);
  // double weightSum = 0.0;
  // for (int j = 0; j < nSamples; j++) {
  //   wt[j] = (2 * (j + 1) - nSamples - 1);
  //   weightSum += wt[j];
  // }
  // double meanWeight = weightSum / nSamples;
  // for (int j = 0; j < nSamples; j++) {
  //   wt[j] -= meanWeight;  // Center weights around zero
  // }

  // Initialize weights (example: rank-based weights)
  NumericVector wt(nSamples);
  for (int j = 0; j < nSamples; j++) {
    wt[j] = (2 * (j + 1) - nSamples - 1);
  }

  NumericVector gcc(nEdges), gcc_pval(nEdges),
  gcc1_vec(nEdges), gcc2_vec(nEdges),
  pcc(nEdges), pcc_pval(nEdges),
  scc(nEdges), scc_pval(nEdges),
  kcc(nEdges), kcc_pval(nEdges);

  MultiCorrWorker worker(expression, ranks, wt, src, tgt, nSamples,
                         bootstrapIterations, useBestGCC, asymmetricGCC,
                         gcc, gcc_pval, gcc1_vec, gcc2_vec,
                         pcc, pcc_pval, scc, scc_pval, kcc, kcc_pval);

  parallelFor(0, nEdges, worker);

  return DataFrame::create(
    _["GCC"] = gcc, _["GCC_pvalue"] = gcc_pval,
    _["GCC1"] = gcc1_vec, _["GCC2"] = gcc2_vec,
    _["PCC"] = pcc, _["PCC_pvalue"] = pcc_pval,
    _["SCC"] = scc, _["SCC_pvalue"] = scc_pval,
    _["KCC"] = kcc, _["KCC_pvalue"] = kcc_pval
  );
}
